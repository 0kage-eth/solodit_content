**Auditor**

[Pashov Audit Group](https://twitter.com/PashovAuditGrp)

# Findings

## High Risk

### [H-01] Mints can be bricked from NFT redemptions

**Severity**

**Impact:** High, prevents subsequent Pupnik sales

**Likelihood:** Medium, can be easily performed by malicious parties

**Description**

Pupnik NFTs can be redeemed at any point in time after it has been minted. Redeeming a Pupnik whose ID is strictly less than `amountMinted` while the sale is ongoing will cause subsequent sales to revert, because the redemption decrements `amountMinted`, which the sale relies on.

The decrement will attempt to mint the existing ID of `amountMinted` before it is decremented.

```solidity
uint256 currentAmount = amountMinted;

for (uint256 i = 1; i <= quantity;) {
  _mint(msg.sender, currentAmount + i);
  ++i;
}
```

**POC**

```solidity
function test_dos_sale(uint256 amount) public {
  // setup: mint 2-5 NFTs (exclude 1 because we need to redeem NFT id < lastMinted)
  amount = bound(amount, 2, 5);
  _deploy();

  changePrank(owner);
  pupniks.setSignerAddress(signer);
  pupniks.toggleSaleStatus();
  changePrank(user);

  uint256 nonce = 0;

  (bytes32 hash, uint8 v, bytes32 r, bytes32 s) = getSignature(user, nonce, amount, signerPkey);

  pupniks.mintPupnik{value: 0.5 ether * amount}(hash, abi.encodePacked(r, s, v), nonce, amount);

  // redeem 1 NFT
  pupniks.redeemPupnik(1);

  // then try to mint more, but it reverts with TokenAlreadyExists()
  nonce = 1;
  (hash, v, r, s) = getSignature(user, nonce, amount, signerPkey);
  vm.expectRevert(ERC721.TokenAlreadyExists.selector);
  pupniks.mintPupnik{value: 0.5 ether * amount}(hash, abi.encodePacked(r, s, v), nonce, amount);
}
```

**Recommendations**

Either have a separate variable that only keeps track of minted Pupniks and never decrements, or delay Pupnik redemptions for a fixed period till the sale is deemed complete.

## Low Risk

### [L-01] Gas rewards can be lost due to the vesting period

On Blast, gas rewards generated by the contract can be collected by calling the `claimAllGas()` function on the Blast contract. However, this loses some amount of rewards.

Gas fees consumed by a contract are eligible to be collected by the same contract after a vesting period. Initially, only 50% of the gas fees can be collected, which increases to 100% linearly over a span of 30 days.

When `claimAllGas()` is called, it claims all gas rewards that are currently available and removes all unvested rewards. This can lead to some gas fees being lost, which were still in the process of being vested. This can be different from the result of the `claimableGas` function, which assumes complete vesting.

Consider adding a `claimGasAtMinClaimRate()` function, which will claim gas fees only above a certain vesting threshold.

Refer to Blast docs [here](https://docs.blast.io/building/guides/gas-fees#claiming-gas-fees)

### [L-02] Incorrect event name breaks ERC7572 compliance

ERC-7572 states that the `ContractURIUpdated()` event SHOULD be emitted on updates to the contract metadata for off-chain indexers to query the contract.

However, the event name is incorrectly named `ContractURISet()` which also incorrectly includes an argument.

```diff
- event ContractURISet(string URI);
+ event ContractURIUpdated();
```
